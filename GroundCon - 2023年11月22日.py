# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GroundCon.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QApplication, QPushButton, QWidget,QCheckBox
from PyQt5.QtGui import QTextCharFormat, QColor
from PyQt5.QtCore import QDateTime

import pyqtgraph as pg
import time 
import numpy as np
from inputs import get_gamepad
import _thread
import threading
import socket
from PyQt5.QtCore import QObject, pyqtSignal
from RotationComputation import AngularRate_and_Orientation
from RotationComputation import FromEuler_Angle_in_Rad2Matrix as E2M
from RotationComputation import FromMatrix2Euler_Angle_in_Rad as M2E
from RotationComputation import FromQuat2Euler_Angle_in_Rad as Q2E
import struct
import logging


from datetime import datetime
from datetime import date

import csv

startTime = time.perf_counter()



class plot_mannager:
    def __init__(self, fatherWindow, toplabel, data_dim, legend_name, leftlabel = 'rad'):
        global startTime
        self. plotcurve = fatherWindow.addPlot(colspan=2)
        self. plotcurve.setLabel('bottom', 'Time', 's')
        self. plotcurve.setLabel('top', toplabel)
        self. plotcurve.setLabel('left', toplabel, leftlabel)
        self. plotcurve.setXRange(-10, 0)
        self. plotcurve.showGrid(x=True, y=True)
        
        self. dim = data_dim
        self. l_name_list = legend_name
        
        self. chunkSize = 20
        self. maxChunks = 20
        
        self. curves_list = []
        self. data_list = []
        self. plot_ptr_list = []

        self. color_list = []
        self. color_list.append((65, 105, 225))
        self. color_list.append((205, 85, 85))
        self. color_list.append((34, 139, 34))
        self. color_list.append((153, 50,204))
        
        self. focused_color = (252, 253, 191)
        self. released_color =(254,254,248)
        
        self. adc_float = 0.0
        self. draw_legned_count = 0
        
        for i in range(self. dim):
            self.curves_list.append ([])
            self.data_list.append (np.zeros((self. chunkSize + 1, 2)))
            self.plot_ptr_list.append (0)
            
    def set_focused(self):
        viewbox = self. plotcurve.getViewBox()
        viewbox.setBackgroundColor(self. focused_color ) 
        
    def release_focused(self):
        viewbox = self. plotcurve.getViewBox()
        viewbox.setBackgroundColor(self. released_color)     
        
    def update_plot( self, data2plot):
        global startTime
        now = time.perf_counter()

        for j in range( self. dim ):
            for c in self. curves_list[j]:
                c.setPos(-(now - startTime), 0)
                
            i = self. plot_ptr_list[j] % self. chunkSize
            if i == 0:
                
                penhere = pg.mkPen(color=self. color_list[j], width=3)
                if self.draw_legned_count == 0 and (not self. l_name_list[j]==''):
                    # print('draw legned')
                    self.plotcurve.addLegend()
                    curve = self.plotcurve.plot(pen=penhere,  name = self. l_name_list[j])
                else:
                    curve = self.plotcurve.plot(pen=penhere)
                self.curves_list[j].append(curve)
                last = self. data_list[j][-1]
                self. data_list[j] = np.empty((self. chunkSize + 1, 2))
                self. data_list[j][0] = last
                while len(self.curves_list[j]) > self. maxChunks:
                    curve = self.curves_list[j].pop(0)
                    self.plotcurve.removeItem(curve)
                
            else:
                if len(self.curves_list[j]) > 0:
                    curve = self.curves_list[j][-1]
            self.data_list[j][i + 1, 0] = now - startTime
            self.data_list[j][i + 1, 1] = data2plot[j]
            curve.setData(x=self. data_list[j][:i + 2, 0], y=self. data_list[j][:i + 2, 1])
            
            self. plot_ptr_list[j] += 1
            
            if i == 0 and j == (self.dim -1):
                 self.draw_legned_count = self.draw_legned_count + 1
        
        if (self.draw_legned_count >=  self.maxChunks):
            self.draw_legned_count = 0
        
class slideCurve:
    roll_real = 0
    roll_ref = 0
    
    pitch_real = 0
    pitch_ref = 0
    
    yaw_real = 0
    yaw_ref = 0
    
    adc1 = 0
    adc2 = 0
    
    angular_rate_roll_real = 0
    angular_rate_roll_ref = 0
    
    angular_rate_pitch_real = 0
    angular_rate_pitch_ref = 0
    
    angular_rate_yaw_real = 0
    angular_rate_yaw_ref = 0
    
    altitude = 0
    altitude_ref = 0
    
    left_horizon = 0
    left_vertical = 0
    right_horizon = 0
    right_vertical = 0
    
    def __init__(self, fatherWindow):
        self.win = pg.GraphicsLayoutWidget(fatherWindow, show=True)
        self.win.setWindowTitle('Remote flapper Data')
        self.win.setBackground((254,254,248))
    
        
        self.roll_plot_manager = plot_mannager(self. win, 'Roll angle', 2, ['Real','Ref'])
        self.roll_r_plot_manager = plot_mannager(self. win, 'Roll angular rate', 2, ['Real','Ref'], leftlabel= 'rad/s')
        self.adcs_plot_manager = plot_mannager(self. win, 'Adcs', 2, ['adc 1','adc 2'], leftlabel= '')
        
        self.win.nextRow()
        
        self.pitch_plot_manager = plot_mannager(self. win, 'Pitch angle', 2, ['Real','Ref'])
        self.pitch_r_plot_manager = plot_mannager(self. win, 'Pitch angular rate', 2, ['Real','Ref'], leftlabel= 'rad/s')
        self.alt_plot_manager = plot_mannager(self. win, 'Altitude', 2, ['Real','Ref'], leftlabel= 'm')
        
        self.win.nextRow()
        
        self.yaw_plot_manager = plot_mannager(self. win, 'Yaw angle', 2, ['Real','Ref'])
        self.yaw_r_plot_manager = plot_mannager(self. win, 'Yaw angular rate', 2, ['Real','Ref'], leftlabel= 'rad/s')
        self.Xbox_plot_manager = plot_mannager(self. win, 'Xbox', 4, ['left_horizon','left_vertical','right_horizon','right_vertical'], leftlabel= '')

        self.all_color_changing_manager= [self.roll_plot_manager, self.pitch_plot_manager, self.yaw_plot_manager,\
                                         self.roll_r_plot_manager, self.pitch_r_plot_manager, self.yaw_r_plot_manager]
        
        
    def update_curves(self):
        self.roll_plot_manager.update_plot([self. roll_real, self. roll_ref])
        self.pitch_plot_manager.update_plot([self. pitch_real, self. pitch_ref])
        self.yaw_plot_manager.update_plot([self. yaw_real, self. yaw_ref])
        
        self.roll_r_plot_manager.update_plot([self. angular_rate_roll_real, self. angular_rate_roll_ref])
        self.pitch_r_plot_manager.update_plot([self. angular_rate_pitch_real, self. angular_rate_pitch_ref])
        self.yaw_r_plot_manager.update_plot([self. angular_rate_yaw_real, self. angular_rate_yaw_ref])
        
        self.adcs_plot_manager.update_plot([self. adc1, self. adc2])
        self.alt_plot_manager.update_plot([self.altitude, self. altitude_ref])
        self.Xbox_plot_manager.update_plot([self.left_horizon, self. left_vertical, self. right_horizon, self. right_vertical])
        
    def focuse_on_angle(self):
        for manager in self.all_color_changing_manager:
            manager.release_focused()
        for i in range(0,2):
            self.all_color_changing_manager[i].set_focused()
        self.all_color_changing_manager[5].set_focused()
            
    def focuse_on_angularRate(self):
        for manager in self.all_color_changing_manager:
            manager.release_focused()
        for i in range(3,6):
            self.all_color_changing_manager[i].set_focused()
            
    def release_all_focuse(self):
        for manager in self.all_color_changing_manager:
            manager.release_focused()

class game_pad_manager(QObject):
    BTN_NORTH_signal = pyqtSignal()
    BTN_EAST_signal = pyqtSignal()
    BTN_SOUTH_signal = pyqtSignal()
    BTN_WEST_signal = pyqtSignal()
    BTN_TL_signal = pyqtSignal()
    BTN_TR_signal = pyqtSignal()
    ABS_Z_RZ_Trigger_singal = pyqtSignal()
    
    def __init__(self, parent=None):
        super(game_pad_manager, self).__init__(parent)
        self. ABS_X = 0
        self. ABS_Y = 0
        self. ABS_Z = 0
        self. ABS_RX = 0
        self. ABS_RY = 0
        self. ABS_RZ = 0
        self. BTN_NORTH = 0
        self. BTN_EAST = 0
        self. BTN_SOUTH = 0
        self. BTN_WEST = 0
        self. BTN_TL = 0
        self. BTN_TR = 0
        
        self. ABS_Z_RZ_Triggered = False
        self. ABS_Z_RZ_Trigger_Thers_upper = 0.9
        self. ABS_Z_RZ_Trigger_Thers_lower = 0.2
        # self. BTN_NORTH_signal = pyqtSignal()
        
        
        
        
        
        _thread.start_new_thread(self.listening_gamepad,())

        
        self. ABS_XY_NORM_CONSTANT = 32768.0

        self. ABS_Z_NORM_CONSTANT  = 255.0

        
        self. is_normalize = 1
    
    def listening_gamepad(self):
        while True:
            try:
                events = get_gamepad()
                for event in events: 
                    # print(event.code +"  ",event.state)
                    match event.code:
                        case 'ABS_X': 
                            self. ABS_X =  event.state
                            if self. is_normalize:
                                self. ABS_X = self. ABS_X / self. ABS_XY_NORM_CONSTANT
                        case 'ABS_Y': 
                            self. ABS_Y =  event.state
                            if self. is_normalize:
                                self. ABS_Y = self. ABS_Y / self. ABS_XY_NORM_CONSTANT
                        case 'ABS_Z': 
                            self. ABS_Z =  event.state
                            if self. is_normalize:
                                self. ABS_Z = self. ABS_Z / self. ABS_Z_NORM_CONSTANT
                        case 'ABS_RX': 
                            self. ABS_RX =  event.state
                            if self. is_normalize:
                                self. ABS_RX = self. ABS_RX / self. ABS_XY_NORM_CONSTANT
                        case 'ABS_RY': 
                            self. ABS_RY =  event.state
                            if self. is_normalize:
                                self. ABS_RY = self. ABS_RY / self. ABS_XY_NORM_CONSTANT
                        case 'ABS_RZ': 
                            self. ABS_RZ =  event.state
                            if self. is_normalize:
                                self. ABS_RZ = self. ABS_RZ / self. ABS_Z_NORM_CONSTANT
                        case 'BTN_NORTH': 
                            self. BTN_NORTH =  event.state
                            if self. BTN_NORTH == 1:
                                self. BTN_NORTH_signal.emit()
                        case 'BTN_EAST': 
                            self. BTN_EAST =  event.state
                            if self. BTN_EAST == 1:
                                self. BTN_EAST_signal.emit()
                        case 'BTN_SOUTH': 
                            self. BTN_SOUTH =  event.state
                            if self. BTN_SOUTH == 1:
                                self. BTN_SOUTH_signal.emit()
                        case 'BTN_WEST': 
                            self. BTN_WEST =  event.state
                            if self. BTN_WEST == 1:
                                self. BTN_WEST_signal.emit()
                        case 'BTN_TL': 
                            self. BTN_TL =  event.state
                            if self. BTN_TL == 1:
                                self. BTN_TL_signal.emit()
                        case 'BTN_TR': 
                            self. BTN_TR =  event.state
                            if self. BTN_TR == 1:
                                self. BTN_TR_signal.emit()            
                    if self. ABS_Z  > self. ABS_Z_RZ_Trigger_Thers_upper and \
                    self. ABS_RZ > self. ABS_Z_RZ_Trigger_Thers_upper and \
                    not self. ABS_Z_RZ_Triggered:
                        self. ABS_Z_RZ_Triggered = True
                        self. ABS_Z_RZ_Trigger_singal.emit()
                        
                    if self. ABS_Z  <= self. ABS_Z_RZ_Trigger_Thers_upper and \
                    self. ABS_RZ <= self. ABS_Z_RZ_Trigger_Thers_upper:
                        self. ABS_Z_RZ_Triggered = False                    
            except:
                time.sleep(0.1)
                
   
                
class socket_manager(QObject):
    record_complete_signal = pyqtSignal()
    TCP_write_thread = threading.Lock()
    
    def __init__(self, host_IP, host_port_name, remote_IP, remote_port_name, parent=None):
        super(socket_manager, self).__init__(parent)
        self. my_host_IP = host_IP
        self. my_host_port_name = host_port_name
        self. my_remote_IP = remote_IP
        self. my_remote_port_name = remote_port_name
        self. mysocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self. mysocket.bind(("",self. my_host_port_name))
        
        
        self. record_start_time = time. time()
        
        # listening things
        self. read_length = 2000
        self. Frame_read_complete = True
        self. Frame_data_count = 0
        self. is_recording = False
        self. is_checked = False
        
        
        self. adc_Record = []
        self. imu_pwm_Record = []
        self. Frame_data = []
        
        self. adc1_to_plot = 0
        self. adc2_to_plot = 0
        
        self. roll_to_plot = 0
        self. pitch_to_plot = 0
        self. yaw_to_plot  = 0
        
        self. quaternion_w = 1
        self. quaternion_x = 0
        self. quaternion_y = 0
        self. quaternion_z = 0
        
        self. roll_r_to_plot = 0
        self. pitch_r_to_plot = 0
        self. yaw_r_to_plot = 0
        
        self. alt_to_plot = 0
        
        _thread.start_new_thread(self.listening_thread,())
        _thread.start_new_thread(self.recording_thread,())
        # recording things
        self. record_length = 30
        self. time_has_been_recording = 0
        
        current_day = date.today().strftime("_%Y_%m_%d_")
        current_time = datetime.now().strftime("%I_%M_%S_%p")

        self. adc_File_name = "UIData/adc_Rec" +current_day + current_time +".csv"
        self. imu_pwm_File_name = "UIData/imu_pwm_Rec" +current_day + current_time +".csv"


        
        
    def listening_thread(self):
        DATA_MODE = 1
        INFO_MODE = 2
        
        self. Info_data_rec = 0
        self. obtained_data_mode = DATA_MODE # DATA_MODE is more frequent
        while True:
            data = self. mysocket. recv(self. read_length)
            for datum in data:
                if datum == 85 and self. Frame_read_complete and self. Frame_data_count == 0: # first byte 0x55
                    self. Frame_read_complete = False
                    self. Frame_data_count = self. Frame_data_count + 1
                    self. Frame_data  = []
                    continue
                    # print('Frame got!')
                if datum == 85 and (not self. Frame_read_complete) and self. Frame_data_count == 1: # second byte 0x55
                    self. Frame_data_count = self. Frame_data_count + 1
                    time_length_has_not_rec_data_in_sec = 0.0
                    continue
                if self. Frame_data_count == 2 and (not self. Frame_read_complete) and datum == 115: # third byte 's'
                    self. Frame_data_count = self. Frame_data_count + 1
                    self. obtained_data_mode = DATA_MODE
                    continue
                if self. Frame_data_count == 3 and (not self. Frame_read_complete): # get the data_number
                    self. Frame_data_count = self. Frame_data_count + 1
                    Info_data_count = datum
                    self. Info_data_rec = datum
                    self. is_checked = False
                    sum_check = 0
                    continue
                
                if self. Frame_data_count == 4 and Info_data_count > 0 and (not self. Frame_read_complete):
                    Info_data_count = Info_data_count - 1
                    self. Frame_data .append(datum)
                    sum_check = sum_check +  datum
                    continue
                
                if self. Frame_data_count == 4 and Info_data_count == 0 and (not self. Frame_read_complete):
                    self. is_checked = (datum == sum_check & 0xFF)
                    
                
                # print(Frame_data)
                if  len(self. Frame_data ) == self. Info_data_rec and self. is_checked and self. obtained_data_mode == DATA_MODE:
                    read_ptr = 0
                    int_values = self. Frame_data [read_ptr:read_ptr + 8]
                    binary_data = struct.pack('8B', *int_values)
                    time_stamp = struct.unpack('d', binary_data)[0]
                    # Frame[1] = double_value
                    
                    read_ptr = read_ptr + 8
                    # print(Frame_data) 
                    FramesInaRead = 20                 
                    for i in range(FramesInaRead):
                        Frame = [0.0] * 3
                        if i == 0:
                            Frame[0] = time_stamp
                        int_values = self. Frame_data [read_ptr:read_ptr + 4]
                        binary_data = struct.pack('4B', *int_values)
                        float_value = struct.unpack('f', binary_data)[0]
                        Frame[1] = float_value
                        int_values = self. Frame_data [read_ptr + 4 * FramesInaRead : read_ptr + 4 + 4 * FramesInaRead]
                        binary_data = struct.pack('4B', *int_values)
                        float_value = struct.unpack('f', binary_data)[0]
                        Frame[2] = float_value
                        read_ptr = read_ptr + 4
                        
                        if self.is_recording:
                            self. adc_Record.append(Frame)
                    
                    read_ptr = read_ptr +  4 * FramesInaRead
                    # os.system('cls' if os.name == 'nt' else 'clear')
                    # print("ADC2: ",Frame[1])
                    self. adc1_to_plot = Frame[1]
                    self. adc2_to_plot = Frame[2]
                    
                    Imu_datum_no = 15
                    ImuFrame = [0.0] * Imu_datum_no
                    for i in range(Imu_datum_no):
                        int_values = self. Frame_data [read_ptr:read_ptr + 4]
                        binary_data = struct.pack('4B', *int_values)
                        ImuFrame[i] = struct.unpack('f', binary_data)[0]
                        read_ptr = read_ptr + 4
                    
                    self. quaternion_w = ImuFrame[3]
                    self. quaternion_x = ImuFrame[0]
                    self. quaternion_y = ImuFrame[1]
                    self. quaternion_z = ImuFrame[2]
                    
                    # self. roll_to_plot = self. quaternion_x
                    # self. pitch_to_plot = self. quaternion_y 
                    # self. yaw_to_plot = self. quaternion_z
                    
                    [self. roll_to_plot,  self. pitch_to_plot,  self. yaw_to_plot] = Q2E( [ self. quaternion_w,\
                                                                                            self. quaternion_x,\
                                                                                            self. quaternion_y,\
                                                                                            self. quaternion_z])
                    [self. roll_r_to_plot, self. pitch_r_to_plot, self. yaw_r_to_plot] = ImuFrame[4 : 7]
                    self. alt_to_plot = ImuFrame[14] * 10
                    
                    pwmFrame = [0] * 2
                    for i in range(2):
                        int_values = self. Frame_data [read_ptr:read_ptr + 2]
                        binary_data = struct.pack('2B', *int_values)
                        pwmFrame[i] = struct.unpack('H', binary_data)[0]
                        read_ptr = read_ptr + 2
                        
                    if self.is_recording:
                            self. imu_pwm_Record.append([time_stamp] + ImuFrame + pwmFrame)
                        
                    # print(adc_Frame)
                # IF all the cases are not triggered.
                self. Frame_data_count = 0
                self. Frame_read_complete = True
                Info_data_count = 0
                self. Frame_data  = []
    
    def recording_thread(self):
        while (True):
            time.sleep(0.1)
            if self. is_recording:
                self. time_has_been_recording = time.perf_counter() - self. record_start_time
            if self. is_recording and (self. time_has_been_recording  < self. record_length):
                with open(self. adc_File_name ,  'a', newline='') as file:
                    writer = csv.writer(file)
                    writer.writerows(self.adc_Record)
                self.adc_Record = []
                
                with open(self. imu_pwm_File_name, 'a', newline='') as file:
                    writer = csv.writer(file)
                    writer.writerows(self.imu_pwm_Record)
                self. imu_pwm_Record = []
            if self. is_recording and (self. time_has_been_recording  >= self. record_length):
                self. record_complete_signal. emit()
    
    def pack_bytes(self, category, data):
        frame_head = "UU"
        frame_head_bytes = frame_head.encode()
        
        cate_bytes = category.encode()
        
        data_no_bytes = bytes()
        data_bytes = bytes()
        check_sum_bytes = bytes()
        
        FLOAT_LENGTH_IN_BYTES = 4
        
        match category:
            case "S":
                data_no = len(data)
                data_no_bytes = data_no.to_bytes(1)
                data_bytes = data.encode()
                check_sum = 0
                for datum in data:
                    check_sum = check_sum + ord(datum)
                check_sum = check_sum & 0xFF
                check_sum_bytes = check_sum.to_bytes(1)
        
            # case "F":
            #     data_no = len(data) * FLOAT_LENGTH_IN_BYTES
            #     data_no_bytes = data_no.to_bytes(1)
            #     for datum in data:
            #         data_bytes = data_bytes + struct.pack('f', datum)
            #     check_sum = 0
            #     for d_byte_int in data_bytes:
            #         check_sum = check_sum + d_byte_int
            #     check_sum = check_sum & 0xFF
            #     check_sum_bytes = check_sum.to_bytes(1)
                
            case "A"|"F"|"#":
                data_no = len(data) * FLOAT_LENGTH_IN_BYTES
                data_no_bytes = data_no.to_bytes(1)
                for datum in data:
                    data_bytes = data_bytes + struct.pack('f', datum)
                check_sum = 0
                for d_byte_int in data_bytes:
                    check_sum = check_sum + d_byte_int
                check_sum = check_sum & 0xFF
                check_sum_bytes = check_sum.to_bytes(1)
                 
        send_bytes = frame_head_bytes + cate_bytes +  data_no_bytes + data_bytes + check_sum_bytes
        return send_bytes   

                      
    def send_arm_command(self):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("S","AA")   
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
    
    
    def send_disarm_command(self):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("S","DD") 
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
    
    def send_attitude_command(self, attitude_command:list):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("A", attitude_command) 
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
    
    def send_force_command(self, forces_and_torques:list):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("F", forces_and_torques) 
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
    
    def send_position_command(self, alt_and_heading:list):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("P", alt_and_heading) 
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
            
    def send_calibration_command(self, calibration_paras:list):
        self. TCP_write_thread.acquire()
        try:       
            send_bytes = self.pack_bytes("#", calibration_paras) 
            self. mysocket.sendto(send_bytes, (self.my_remote_IP, self. my_remote_port_name))
        finally:
            self. TCP_write_thread.release()
    
                    
    
    def start_record(self, record_time_length):
        current_day = date.today().strftime("_%Y_%m_%d_")
        current_time = datetime.now().strftime("%I_%M_%S_%p")

        self. adc_File_name = "UIData/adc_Rec" +current_day + current_time +".csv"
        self. imu_pwm_File_name = "UIData/imu_pwm_Rec" +current_day + current_time +".csv"
        
        with open(self. adc_File_name ,  'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Time stamp(sec)', 'adc1', 'adc2'])

                
        with open(self. imu_pwm_File_name, 'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Time stamp(sec)', 
                             'quaternion_x', 'quaternion_y','quaternion_z','quaternion_w',
                             'roll_angular_rate','pitch_angular_rate','yaw_angular_rate',
                             'acc_X','acc_Y','acc_Z',
                             'mag_X','mag_Y','mag_Z',
                             'pressure','altitude'])

        
        self. adc_Record = []
        self. imu_pwm_Record = []
        self. time_has_been_recording = 0
        self. is_recording = True
        self. record_start_time = time.perf_counter()
        self. record_length = record_time_length
        
    
    def stop_record(self):
        self. adc_Record = []
        self. imu_pwm_Record = []
        self. time_has_been_recording = 0
        self. is_recording = False
                 
class Ui_MainWindow(QMainWindow):
    ABS_X_value = 0
    ABS_Y_value = 0
    ABS_RX_value = 0
    ABS_RY_value = 0
    calibration_completed_signal = pyqtSignal()
    progressBarupdate_singal = pyqtSignal(int)
    
    def __init__(self):
        super().__init__()
        self.setObjectName("QFlapControl")
        self.resize(1500, 1100)
        self.setMinimumSize(QtCore.QSize(1500, 1100))
        self.widget = QtWidgets.QWidget(self)
        self.widget.setMinimumSize(QtCore.QSize(1500, 1100))
        self.widget.setObjectName("widget")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.GCIPlabel = QtWidgets.QLabel(self.widget)
        self.GCIPlabel.setMinimumSize(QtCore.QSize(200, 25))
        self.GCIPlabel.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.GCIPlabel.setFont(font)
        self.GCIPlabel.setObjectName("GCIPlabel")
        self.verticalLayout_2.addWidget(self.GCIPlabel)
        self.GCportlable = QtWidgets.QLabel(self.widget)
        self.GCportlable.setMinimumSize(QtCore.QSize(200, 25))
        self.GCportlable.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.GCportlable.setFont(font)
        self.GCportlable.setObjectName("GCportlable")
        self.verticalLayout_2.addWidget(self.GCportlable)
        self.RBIPlabel = QtWidgets.QLabel(self.widget)
        self.RBIPlabel.setMinimumSize(QtCore.QSize(200, 25))
        self.RBIPlabel.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.RBIPlabel.setFont(font)
        self.RBIPlabel.setObjectName("RBIPlabel")
        self.verticalLayout_2.addWidget(self.RBIPlabel)
        self.RBportlabel = QtWidgets.QLabel(self.widget)
        self.RBportlabel.setMinimumSize(QtCore.QSize(200, 25))
        self.RBportlabel.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.RBportlabel.setFont(font)
        self.RBportlabel.setObjectName("RBportlabel")
        self.verticalLayout_2.addWidget(self.RBportlabel)
        self.line = QtWidgets.QFrame(self.widget)
        self.line.setMaximumSize(QtCore.QSize(300, 16777215))
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout_2.addWidget(self.line)
        self.RecTlable = QtWidgets.QLabel(self.widget)
        self.RecTlable.setMinimumSize(QtCore.QSize(200, 25))
        self.RecTlable.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.RecTlable.setFont(font)
        self.RecTlable.setObjectName("RecTlable")
        self.verticalLayout_2.addWidget(self.RecTlable)
        self.RecdoubleSpinBox = QtWidgets.QDoubleSpinBox(self.widget)
        self.RecdoubleSpinBox.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.RecdoubleSpinBox.setFont(font)
        self.RecdoubleSpinBox.setMaximum(9999.0)
        self.RecdoubleSpinBox.setProperty("value", 30.0)
        self.RecdoubleSpinBox.setObjectName("RecdoubleSpinBox")
        self.verticalLayout_2.addWidget(self.RecdoubleSpinBox)
        self.line_3 = QtWidgets.QFrame(self.widget)
        self.line_3.setMaximumSize(QtCore.QSize(300, 16777215))
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")
        self.verticalLayout_2.addWidget(self.line_3)
        self.Xgainlabel = QtWidgets.QLabel(self.widget)
        self.Xgainlabel.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Xgainlabel.setFont(font)
        self.Xgainlabel.setObjectName("Xgainlabel")
        self.verticalLayout_2.addWidget(self.Xgainlabel)
        self.RatiodoubleSpinBox = QtWidgets.QDoubleSpinBox(self.widget)
        self.RatiodoubleSpinBox.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.RatiodoubleSpinBox.setFont(font)
        self.RatiodoubleSpinBox.setMinimum(0.1)
        self.RatiodoubleSpinBox.setMaximum(10.00)
        self.RatiodoubleSpinBox.setDecimals(4)
        self.RatiodoubleSpinBox.setProperty("value", 1.0)
        self.RatiodoubleSpinBox.setObjectName("RatiodoubleSpinBox")
        self.verticalLayout_2.addWidget(self.RatiodoubleSpinBox)
        self.Xcurvelabel = QtWidgets.QLabel(self.widget)
        self.Xcurvelabel.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Xcurvelabel.setFont(font)
        self.Xcurvelabel.setObjectName("Xcurvelabel")
        self.verticalLayout_2.addWidget(self.Xcurvelabel)
        self.curveComboBox = QtWidgets.QComboBox(self.widget)
        self.curveComboBox.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.curveComboBox.setFont(font)
        self.curveComboBox.setObjectName("curveComboBox")
        items = ["Linear", "Exponential (smooth)", "Tanh (aggressive)"]
        self.curveComboBox.addItems(items)
        self.verticalLayout_2.addWidget(self.curveComboBox)
        
        self.Reverselabel = QtWidgets.QLabel("Reverse")
        self.Reverselabel.setMinimumSize(QtCore.QSize(200, 25))
        self.Reverselabel.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Reverselabel.setFont(font)
        self.Reverselabel.setObjectName("Reverselabel")
        self.verticalLayout_2.addWidget(self.Reverselabel)
        
        self.reverselayout = QtWidgets.QHBoxLayout()
        self.reverselayout.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)
        self.reverselayout.setObjectName("reverselayout")
        self.verticalLayout_2.addLayout(self.reverselayout)
        self.Rcheckbox = QCheckBox("Roll")
        self.Rcheckbox.setChecked(False)
        self.reverselayout.addWidget(self.Rcheckbox)
        self.Pcheckbox = QCheckBox("Pitch")
        self.Pcheckbox.setChecked(False)
        self.reverselayout.addWidget(self.Pcheckbox)
        self.Ycheckbox = QCheckBox("Yaw")
        self.Ycheckbox.setChecked(False)
        self.reverselayout.addWidget(self.Ycheckbox)
        
        self.line_5 = QtWidgets.QFrame(self.widget)
        self.line_5.setMaximumSize(QtCore.QSize(300, 16777215))
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")
        self.verticalLayout_2.addWidget(self.line_5)
        self.Stalable = QtWidgets.QLabel(self.widget)
        self.Stalable.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.Stalable.setFont(font)
        self.Stalable.setObjectName("Stalable")
        self.verticalLayout_2.addWidget(self.Stalable)
        self.textBrowser_2 = QtWidgets.QTextBrowser(self.widget)
        self.textBrowser_2.setMinimumSize(QtCore.QSize(200, 300))
        self.textBrowser_2.setMaximumSize(QtCore.QSize(300, 16777215))
        self.textBrowser_2.setObjectName("textBrowser_2")
        self.verticalLayout_2.addWidget(self.textBrowser_2)
        # spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        # self.verticalLayout_2.addItem(spacerItem)
        # self.ModeSbutton = QtWidgets.QPushButton(self.widget)
        # self.ModeSbutton.setMaximumSize(QtCore.QSize(300, 25))
        # self.ModeSbutton.setMinimumSize(QtCore.QSize(200, 25))
        # font = QtGui.QFont()
        # font.setFamily("Arial")
        # font.setPointSize(10)
        # self.ModeSbutton.setFont(font)
        # self.ModeSbutton.setObjectName("ModeSbutton")
        # self.verticalLayout_2.addWidget(self.ModeSbutton)
        self.Modelable = QtWidgets.QLabel(self.widget)
        self.Modelable.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.Modelable.setFont(font)
        self.Modelable.setObjectName("Modelable")
        self.verticalLayout_2.addWidget(self.Modelable)
        
        self.ModecomboBox = QtWidgets.QComboBox(self.widget)
        self.ModecomboBox.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.ModecomboBox.setFont(font)
        self.ModecomboBox.setObjectName("ModecomboBox")
        self. mode_items = ["Manual", "Attitude", "Acrobat", "Autonomous"]
        self.ModecomboBox.addItems(self. mode_items)
        self.verticalLayout_2.addWidget(self.ModecomboBox)
        
        self.line_4 = QtWidgets.QFrame(self.widget)
        self.line_4.setMaximumSize(QtCore.QSize(300, 16777215))
        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")
        self.verticalLayout_2.addWidget(self.line_4)
        self.Calibutton = QtWidgets.QPushButton(self.widget)
        self.Calibutton.setMaximumSize(QtCore.QSize(300, 25))
        self.Calibutton.setMinimumSize(QtCore.QSize(200, 25))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.Calibutton.setFont(font)
        self.Calibutton.setObjectName("Calibutton")
        self.verticalLayout_2.addWidget(self.Calibutton)
        
        self.SelecButton = QtWidgets.QPushButton(self.widget)
        self.SelecButton.setMaximumSize(QtCore.QSize(300, 25))
        self.SelecButton.setMinimumSize(QtCore.QSize(200, 25))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.SelecButton.setFont(font)
        self.SelecButton.setObjectName("Set_Cali.")
        self.verticalLayout_2.addWidget(self.SelecButton)
        
        self.Recbutton = QtWidgets.QPushButton(self.widget)
        self.Recbutton.setMaximumSize(QtCore.QSize(300, 25))
        self.Recbutton.setMinimumSize(QtCore.QSize(200, 25))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.Recbutton.setFont(font)
        self.Recbutton.setWhatsThis("")
        self.Recbutton.setObjectName("Recbutton")
        self.verticalLayout_2.addWidget(self.Recbutton)
        self.progressBar = QtWidgets.QProgressBar(self.widget)
        self.progressBar.setMaximumSize(QtCore.QSize(300, 25))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.progressBar.setFont(font)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.verticalLayout_2.addWidget(self.progressBar)
        self.horizontalLayout.addLayout(self.verticalLayout_2)
        self.line_2 = QtWidgets.QFrame(self.widget)
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.horizontalLayout.addWidget(self.line_2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.curve_widget = QtWidgets.QWidget()
        self.curve_widget.setAutoFillBackground(True)
        self.curve_widget.setObjectName("curve_tab")
        
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.horizontalLayout_2.addLayout(self.horizontalLayout)
        
        self.slC = slideCurve(self.curve_widget)
        self.verticalLayout.addWidget(self.slC.win)
        
        self.gpM = game_pad_manager()
        
        initial_orien = np.mat(np.eye(3))
        initial_ome   = np.mat(np.zeros(3)).T
        self.AaO = AngularRate_and_Orientation(initial_orien, initial_ome, startTime )
        
        _thread.start_new_thread(self.ao_rolling,())
        
        self.gpM.BTN_TR_signal.connect(self.back_flight_mode)
        self.gpM.BTN_TL_signal.connect(self.forward_flight_mode)
        self.switch_focus(self. ModecomboBox.currentIndex())
        
        here_host_IP = '192.168.50.141'
        here_host_port = 6001
        here_remote_IP = '192.168.50.69'
        #'192.168.50.69'
        here_remote_port = 6101
        self. scM = socket_manager(here_host_IP, here_host_port,\
                here_remote_IP, here_remote_port)
        
        self. isArmed = False
        
 
        
        self.gpM.BTN_SOUTH_signal.connect(self.start_recording_infos)
        self.gpM.BTN_EAST_signal.connect(self.stop_recording_infos)
        self.Recbutton.clicked.connect(self. switch_recording_infos)
        self.Calibutton.clicked.connect(self.start_calibration)
        
        self.gpM.ABS_Z_RZ_Trigger_singal.connect(self. switch_arm_infos)
        
        self.scM.record_complete_signal.connect(self. stop_recording_infos)
        self.calibration_completed_signal.connect(self. reset_calubration_button)
        self.progressBarupdate_singal.connect(lambda value: self.progressBar.setValue(value))
        self.ModecomboBox.currentIndexChanged.connect(self.flight_mode_changed)
        
        self.setCentralWidget(self.widget)

        self.retranslateUi(self)
        QtCore.QMetaObject.connectSlotsByName(self)

    
    def start_calibration(self):
        self.Calibutton.setText("Calbrating, please wait..")
        self.Calibutton.setDisabled(True)
        _thread.start_new_thread(self.calibration_thread,())
    
    def reset_calubration_button(self):
        self. Calibutton.setText("Start Calibration")
        self.Calibutton.setEnabled(True)
        
    
        
    def calibration_thread(self):
        calibration_sample_interval = 0.1 # Sample interval in calibration, in seconds   
        calibbration_times = 50 # The total number of samples
        quaternions =[]
        self.InputTextWithoutLog("-Calibration Started in 5 seconds.\n-Please align the vehicle Z axix UP.\n")
        for i in range(5):
            time.sleep(1.0)
            self.InputTextWithoutLog("  "+str(5 - i) +"...\n")
        self.InputText("Calibration Start.\n")
            
        for i in range(calibbration_times):
            quaternions.append(np.array([self.scM.quaternion_w, 
                                         self.scM.quaternion_x,
                                         self.scM.quaternion_y,
                                         self.scM.quaternion_z]))
            time.sleep(calibration_sample_interval)
            # self. progressBar. setValue(int((i+1) / calibbration_times * 100) )
            self. progressBarupdate_singal.emit(int((i+1) / calibbration_times * 100))

        self. progressBarupdate_singal. emit(0)
        quat = self.average_quaternions(quaternions) 
        self.InputText("Calibration Complete [qw qx qy qz]:" + np.array2string(quat)+".")
        
        # time.sleep(0.1)
        self.scM.send_calibration_command( quat.tolist() )   # The quat send to Remote is [qw, qx, qy, qz]
        self. calibration_completed_signal. emit() 
        
    
    def normalize_quaternion(self, q):
        norm = np.linalg.norm(q)
        return q / norm

    # Function to average quaternions
    def average_quaternions(self, quaternions):
        # Normalize all quaternions
        normalized_quaternions = [self.normalize_quaternion(q) for q in quaternions]
        
        # Calculate the sum of quaternions
        sum_quaternion = np.sum(normalized_quaternions, axis=0)
        
        # Normalize the sum to get the average quaternion
        average_quaternion = self. normalize_quaternion(sum_quaternion)
        
        return average_quaternion

    def switch_recording_infos(self):
        if not  self. scM. is_recording:
            self. start_recording_infos()
            return 
        if self. scM. is_recording:
            self. stop_recording_infos()
            return 
    
    def switch_arm_infos(self):
        # print("arm switched")
        if not self. isArmed:
            self. send_arm_signals()
            self.Stalable.setText("Status: Armed.")
            return
        if self. isArmed:
            self. send_disarm_signals()
            self.Stalable.setText("Status: Disarmed.")
            return
            
    
    def send_arm_signals(self):
        if not self. isArmed:
            self. scM. send_arm_command()
            self. InputText("Arm the robot.\n")
            self. isArmed = True
        time.sleep(0.1)
        
    def send_disarm_signals(self):
        if self. isArmed:
            self. scM. send_disarm_command()
            self. InputText("Disarm the robot.\n")
            self. isArmed = False
        time.sleep(0.1)
            
            
    def start_recording_infos(self):
        if not self. scM. is_recording:
            _translate = QtCore.QCoreApplication.translate
            self. scM. record_length = self. RecdoubleSpinBox.value()
            self. scM. start_record( self. RecdoubleSpinBox.value())
            self. InputText("Recording starrted.\n")
            self. Recbutton. setText(_translate("MainWindow", "Stop Recording"))
        time.sleep(0.1)
    
    def InputText(self, Text):
        # char_format = QTextCharFormat()
        # char_format.setForeground(QColor("#FF0000"))
        self. textBrowser_2.setTextColor(QColor("#BB1100"))
        currentDateTime = QDateTime.currentDateTime()
        currentTime = currentDateTime.time()
        self. textBrowser_2.insertPlainText(currentTime.toString("[hh:mm:ss]:"))
        self. textBrowser_2.insertPlainText(Text)
        logging.info(Text)
        cursor = self. textBrowser_2.textCursor()
        cursor.movePosition(cursor.End)
        self. textBrowser_2.setTextCursor(cursor)
        
    def InputTextWithoutLog(self, Text):
        self. textBrowser_2.setTextColor(QColor("#000000"))
        self. textBrowser_2.insertPlainText(Text)
        cursor = self. textBrowser_2.textCursor()
        cursor.movePosition(cursor.End)
        self. textBrowser_2.setTextCursor(cursor)
        
    def stop_recording_infos(self):
        if self. scM. is_recording:
            _translate = QtCore.QCoreApplication.translate
            self. scM. stop_record()
            self. InputText("Recording stopped.\n")
            self. progressBar.setValue(0)
            self. Recbutton. setText(_translate("MainWindow", "Start Recording"))
        time.sleep(0.1)


    def ao_rolling(self):
        division = 20
        count = 0
        computation_gap = 1e-3
        divisor = 20
        while(True):
            count = count + 1
            if count == divisor:
                count = 0
            time.sleep(computation_gap)
            """["Manual", "Attitude", "Acrobat", "Autonomous"]"""
            if self. ModecomboBox:
                match self.ModecomboBox.currentIndex():
                    case 0:
                        if count == 0:
                            self. scM. send_force_command( [self. ABS_Y_value, self.ABS_RX_value, self.ABS_RY_value, self.ABS_X_value])
                        self.AaO.orientation = np.mat(np.eye(3))
                        self.AaO.omega = np.mat(np.zeros(3)).T
                        self.AaO.last_update_time = time.perf_counter()
                        
                    case 1:
                        yaw_changing_rate = 2 * np.pi
                        ABS_X_v = self.ABS_X_value
                        if abs(ABS_X_v) < 0.1:
                            ABS_X_v = 0
                        elif ABS_X_v < -0.1:
                            ABS_X_v = ABS_X_v + 0.1
                        else:
                            ABS_X_v = ABS_X_v - 0.1
                        
                        self. slC. yaw_ref += yaw_changing_rate * ABS_X_v * computation_gap
                        while self. slC. yaw_ref > np.pi:
                            self. slC. yaw_ref -= 2 * np.pi
                        while self. slC. yaw_ref < -np.pi:
                            self. slC. yaw_ref += 2 * np.pi
                            
                        if count == 0:
                            self. scM. send_attitude_command( [self. ABS_Y_value, self.ABS_RX_value, self.ABS_RY_value, self. slC. yaw_ref ])
                        euler_angle_in_rad = np. matrix ([ self.ABS_RX_value, self.ABS_RY_value, 0]).T
                        rotation_matrix = E2M( euler_angle_in_rad)
                        if count == 0:
                            self. AaO. march_forward_with_newOrientation(rotation_matrix, time.perf_counter())
                        self. slC. roll_ref = self. ABS_RX_value
                        self. slC. pitch_ref = self. ABS_RY_value
                        
                        self. slC. angular_rate_roll_ref =  self. AaO. omega[0,0]
                        self. slC. angular_rate_pitch_ref = self. AaO. omega[1,0]
                        self. slC. angular_rate_yaw_ref =   yaw_changing_rate * self.ABS_X_value
                        
                    case 2:
                        angular_rate_in_rad = np. matrix ([ self.ABS_RX_value, self.ABS_RY_value, self.ABS_X_value]).T
                        self. AaO. march_forward_with_newAngularRate(angular_rate_in_rad, time.perf_counter())
                        euler_angle_in_rad = M2E(self. AaO. orientation)
                        self. slC. roll_ref = euler_angle_in_rad[0,0]
                        self. slC. pitch_ref = euler_angle_in_rad[1,0]
                        self. slC. yaw_ref = euler_angle_in_rad[2,0]
                        self. slC. angular_rate_roll_ref =  angular_rate_in_rad[0,0]
                        self. slC. angular_rate_pitch_ref = angular_rate_in_rad[1,0]
                        self. slC. angular_rate_yaw_ref =   angular_rate_in_rad[2,0]
                        
                    case _:
                        self.AaO.orientation = np.mat(np.eye(3))
                        self.AaO.omega = np.mat(np.zeros(3)).T
                        self.AaO.last_update_time = time.perf_counter()


    def switch_focus(self, temp:int):
        match temp:
            case 0:
                self. slC. release_all_focuse()
                self.InputText("Set to Manual mode.\n")
            case 1:
                self. slC. focuse_on_angle()
                self.InputText("Set to Attitude mode.\n")
            case 2:
                self. slC. focuse_on_angularRate()
                self.InputText("Set to Acrobat mode.\n")
            case _:
                self. slC. release_all_focuse()
        
    def back_flight_mode(self):
        temp =  self. ModecomboBox.currentIndex() + 1
        if temp >= len(self. mode_items):
            temp = 0
        self. ModecomboBox. setCurrentIndex(temp)
        self.switch_focus(temp)
        
    def forward_flight_mode(self):
        temp =  self. ModecomboBox.currentIndex() - 1
        if temp < 0:
            temp = len(self. mode_items)-1
        self. ModecomboBox. setCurrentIndex(temp)
        self.switch_focus(temp)
        
    def flight_mode_changed(self):
        temp =  self. ModecomboBox.currentIndex()
        self.switch_focus(temp)
        
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "RoboButterFly Ground Control"))
        hostname = socket.gethostname()
        self.GCIPlabel.setText(_translate("MainWindow", "GroundControl IP is "+socket.gethostbyname(hostname)))
        self.GCportlable.setText(_translate("MainWindow", "GroundControl port is ..."))
        self.RBIPlabel.setText(_translate("MainWindow", "Remote Butterfly IP is ..."))
        self.RBportlabel.setText(_translate("MainWindow", "Remote Butterfly port is ..."))
        self.RecTlable.setText(_translate("MainWindow", "Record time lenght(sec)"))
        self.Xgainlabel.setText(_translate("MainWindow", "X-Box joystick gains"))
        self.Xcurvelabel.setText(_translate("MainWindow", "X-Box joystick curve"))
        self.Stalable.setText(_translate("MainWindow", "Status"))
        # self.ModecomboBox.setText(_translate("MainWindow", "Manual Mode (Click)"))
        self.Modelable.setText(_translate("MainWindow", "Mode (Man. Att. Acro. Autom.)"))
        self.Calibutton.setText(_translate("MainWindow", "Start Calibrate"))
        self.SelecButton.setText(_translate("MainWindow", "Select Set. && Cali."))
        self.Recbutton.setText(_translate("MainWindow", "Start Recording"))

    def exp_curve(self, input):
        return np.exp(np.abs(input))  * input /  np.exp(self.RatiodoubleSpinBox.value()) 
    
    def tanh_curve(self, input):
        return np.tanh(input) / np.tanh(self.RatiodoubleSpinBox.value()) * self.RatiodoubleSpinBox.value()

    def connect_game_pad_and_curve(self):
        
        if self.Rcheckbox.isChecked():
            self. ABS_RX_value = - self. gpM. ABS_RX * self.RatiodoubleSpinBox.value()
        else:
            self. ABS_RX_value = self. gpM. ABS_RX * self.RatiodoubleSpinBox.value()
        
        if self.Pcheckbox.isChecked(): 
            self. ABS_RY_value = - self. gpM. ABS_RY * self.RatiodoubleSpinBox.value()
        else:
            self. ABS_RY_value =  self. gpM. ABS_RY * self.RatiodoubleSpinBox.value()
        
        if self.Ycheckbox.isChecked(): 
             self. ABS_X_value  = - self. gpM. ABS_X * self.RatiodoubleSpinBox.value()
        else:
            self. ABS_X_value  = self. gpM. ABS_X * self.RatiodoubleSpinBox.value()
            
        self. ABS_Y_value  = self. gpM. ABS_Y * self.RatiodoubleSpinBox.value()


        # print(ABS_RX_value)
        
        curve_ind = self. curveComboBox. currentIndex()
        
        match curve_ind:
            case 1:
                self. ABS_RX_value = self. exp_curve(self. ABS_RX_value)
                self. ABS_RY_value = self. exp_curve(self. ABS_RY_value)
                self. ABS_X_value = self. exp_curve(self. ABS_X_value)
                self. ABS_Y_value = self. exp_curve(self. ABS_Y_value)
                
            case 2:
                self. ABS_RX_value = self. tanh_curve(self. ABS_RX_value)
                self. ABS_RY_value = self. tanh_curve(self. ABS_RY_value)
                self. ABS_X_value = self. tanh_curve(self. ABS_X_value)
                self. ABS_Y_value = self. tanh_curve(self. ABS_Y_value)
        
        # match self.curveComboBox.currentIndex():
        #     case 

        
        self. slC. left_horizon = self. ABS_X_value
        self. slC. left_vertical = self. ABS_Y_value
        self. slC. right_horizon = self. ABS_RX_value
        self. slC. right_vertical = self. ABS_RY_value

    def connect_socket_and_curve(self):
        self. slC. roll_real = self. scM. roll_to_plot
        self. slC. pitch_real = self. scM. pitch_to_plot
        self. slC. yaw_real = self. scM. yaw_to_plot
        
        self. slC. angular_rate_roll_real = self. scM. roll_r_to_plot
        self. slC. angular_rate_pitch_real = self. scM. pitch_r_to_plot
        self. slC. angular_rate_yaw_real = self. scM. yaw_r_to_plot
        
        self. slC. adc1 = self. scM. adc1_to_plot
        self. slC. adc2 = self. scM. adc2_to_plot
        
        self. slC. altitude = self. scM. alt_to_plot
        
        if self. scM. is_recording:
            self. progressBar. setValue(int(self. scM. time_has_been_recording / self. scM. record_length* 100) )



 
        
    
        

  



    





def main(args=None):

    # mapwidget =MapWindow()

    import sys
    a = QApplication(sys.argv) 
    
    current_day = date.today().strftime("_%Y_%m_%d_")
    current_time = datetime.now().strftime("%I_%M_%S_%p")
    log_File_name = "logs/Rec" +current_day + current_time +".log"
    logging.basicConfig(filename = log_File_name, level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    window = Ui_MainWindow()
    
    curve_update_timer = pg.QtCore.QTimer()
    curve_update_timer.timeout.connect(window.slC.update_curves)
    curve_update_timer.start(5)

    
    connect_timer = pg.QtCore.QTimer()
    connect_timer.timeout.connect(window.connect_game_pad_and_curve)
    connect_timer.timeout.connect(window.connect_socket_and_curve)
    connect_timer.start(1)
    
    window.show()
    QtGui.QGuiApplication.instance().exec_()
    
    
    

main()